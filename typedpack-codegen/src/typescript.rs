use std::collections::HashSet;

use crate::{Enum, Struct, StructField, StructFieldType};

/// Necessary imports for generated code.
pub const FILE_HEADER: &str = "\
// This file is automatically generated.

/* eslint-disable @typescript-eslint/no-namespace, @typescript-eslint/no-unused-vars */

import {
    arrayHeaderLength,
    bytesHeaderLength,
    decodeArrayLength,
    decodeBoolean,
    decodeBytes,
    decodeFloat32,
    decodeFloat64,
    decodeInt,
    decodeInt64,
    decodeMapKey,
    decodeMapLength,
    decodeString,
    encodeArrayHeader,
    encodeBoolean,
    encodeBytes,
    encodeMapHeader,
    encodeNull,
    encodeFloat32,
    encodeFloat64,
    encodeInt,
    encodeInt64,
    encodeString,
    encodeUint,
    encodeUint64,
    mapHeaderLength,
    stringHeaderLength,
} from \"typedpack\";";

/// Error type for converting [`OptionsInput`] into [`Options`].
#[derive(Clone, Copy, Debug, thiserror::Error)]
pub enum OptionsError {
    #[error(
        "`types_namespace` cannot be empty, can only contain ASCII alphanumeric characters or underscores, and cannot start with a digit"
    )]
    InvalidTypesNamespace,
    #[error(
        "`encode_namespace` cannot be empty, can only contain ASCII alphanumeric characters or underscores, and cannot start with a digit"
    )]
    InvalidEncodeNamespace,
    #[error(
        "`decode_namespace` cannot be empty, can only contain ASCII alphanumeric characters or underscores, and cannot start with a digit"
    )]
    InvalidDecodeNamespace,
    #[error(
        "`encode_array_namespace` cannot be empty, can only contain ASCII alphanumeric characters or underscores, and cannot start with a digit"
    )]
    InvalidEncodeArrayNamespace,
    #[error(
        "`decode_array_namespace` cannot be empty, can only contain ASCII alphanumeric characters or underscores, and cannot start with a digit"
    )]
    InvalidDecodeArrayNamespace,
    #[error(
        "some namespaces have the same name (note that `TypedpackDecodeInternal`, `TypedpackEncodeInternal`, `TypedpackMapLength` and `TypedpackMaxLength` are used internally and cannot be used for the types, encode or decode namespaces)"
    )]
    NamespaceCollision,
}

/// Unvalidated [`Options`] for TypeScript code generation.
///
/// Use [`TryInto::try_into`] to convert this into [`Options`].
///
/// Conversion fails if any namespace name is not a valid identifier, or if there is a name
/// collision among the namespaces. These include the internal namespaces `TypedpackMapLength`,
/// `TypedpackMaxLength` and `TypedpackDecodeInternal`, as well as the public namespaces that were
/// left at their defaults: `Types`, `Encode`, `Decode`, `EncodeArray` and `DecodeArray`.
#[derive(Clone, Debug, Default, PartialEq, Eq, Hash)]
pub struct OptionsInput {
    pub types_namespace: Option<String>,
    pub encode_namespace: Option<String>,
    pub decode_namespace: Option<String>,
    pub encode_array_namespace: Option<String>,
    pub decode_array_namespace: Option<String>,
    pub export_decode_internal_namespace: Option<bool>,
}

/// Validated options for TypeScript code generation.
///
/// Use [`TryInto::try_into`] to convert [`OptionsInput`] into this type.
#[derive(Clone, Debug, PartialEq, Eq, Hash)]
pub struct Options {
    types_namespace: String,
    encode_namespace: String,
    decode_namespace: String,
    encode_array_namespace: String,
    decode_array_namespace: String,
    export_decode_internal_namespace: bool,
}

impl Options {
    pub fn types_namespace(&self) -> &str {
        &self.types_namespace
    }

    pub fn encode_namespace(&self) -> &str {
        &self.encode_namespace
    }

    pub fn decode_namespace(&self) -> &str {
        &self.decode_namespace
    }

    pub fn encode_array_namespace(&self) -> &str {
        &self.encode_array_namespace
    }

    pub fn decode_array_namespace(&self) -> &str {
        &self.decode_array_namespace
    }

    pub fn export_decode_internal_namespace(&self) -> bool {
        self.export_decode_internal_namespace
    }
}

impl TryFrom<OptionsInput> for Options {
    type Error = OptionsError;

    fn try_from(value: OptionsInput) -> Result<Self, Self::Error> {
        let parsed = Self {
            types_namespace: value
                .types_namespace
                .unwrap_or_else(|| String::from("Types")),
            encode_namespace: value
                .encode_namespace
                .unwrap_or_else(|| String::from("Encode")),
            decode_namespace: value
                .decode_namespace
                .unwrap_or_else(|| String::from("Decode")),
            encode_array_namespace: value
                .encode_array_namespace
                .unwrap_or_else(|| String::from("EncodeArray")),
            decode_array_namespace: value
                .decode_array_namespace
                .unwrap_or_else(|| String::from("DecodeArray")),
            export_decode_internal_namespace: value
                .export_decode_internal_namespace
                .unwrap_or(false),
        };

        let is_valid_name = |name: &str| {
            let mut chars = name.chars();
            let Some(first_char) = chars.next() else {
                return false;
            };
            if !first_char.is_ascii_alphabetic() && first_char != '_' {
                return false;
            }
            chars.all(|c| c.is_ascii_alphanumeric() || c == '_')
        };

        if !is_valid_name(&parsed.types_namespace) {
            return Err(OptionsError::InvalidTypesNamespace);
        }
        if !is_valid_name(&parsed.encode_namespace) {
            return Err(OptionsError::InvalidEncodeNamespace);
        }
        if !is_valid_name(&parsed.decode_namespace) {
            return Err(OptionsError::InvalidDecodeNamespace);
        }
        if !is_valid_name(&parsed.encode_array_namespace) {
            return Err(OptionsError::InvalidEncodeArrayNamespace);
        }
        if !is_valid_name(&parsed.decode_array_namespace) {
            return Err(OptionsError::InvalidDecodeArrayNamespace);
        }

        let namespaces_set = HashSet::from([
            &parsed.types_namespace,
            &parsed.encode_namespace,
            &parsed.decode_namespace,
            &parsed.encode_array_namespace,
            &parsed.decode_array_namespace,
            "TypedpackEncodeInternal",
            "TypedpackDecodeInternal",
            "TypedpackMapLength",
            "TypedpackMaxLength",
        ]);
        if namespaces_set.len() != 9 {
            return Err(OptionsError::NamespaceCollision);
        }
        Ok(parsed)
    }
}

impl Enum<'_> {
    /// Generates a TypeScript `enum` and encode/decode functions.
    pub fn typescript_enum(&self, options: &Options) -> String {
        match self {
            Self::Tagged { name, variants } => {
                let mut s = String::from("export namespace ");
                s.push_str(&options.types_namespace);
                s.push_str(" {\n    export enum ");
                s.push_str(name);
                s.push_str(" {\n");

                for variant in variants {
                    s.push_str("        ");
                    s.push_str(variant.name);
                    s.push_str(" = ");
                    s.push_str(&variant.id.to_string());
                    s.push_str(",\n");
                }

                s.push_str("    }\n}\n\nnamespace TypedpackMaxLength {\n    export const ");
                s.push_str(name);
                s.push_str(" = ([tag, value]: ");

                let mut type_union = String::new();
                for (i, variant) in variants.iter().enumerate() {
                    if i != 0 {
                        type_union.push_str(" | ");
                    }
                    type_union.push('[');
                    type_union.push_str(&options.types_namespace);
                    type_union.push('.');
                    type_union.push_str(name);
                    type_union.push('.');
                    type_union.push_str(variant.name);
                    type_union.push_str(", ");
                    type_union.push_str(&options.types_namespace);
                    type_union.push('.');
                    type_union.push_str(variant.r#type);
                    type_union.push(']');
                }

                s.push_str(&type_union);
                s.push_str("): number => {\n");

                for variant in variants {
                    s.push_str("        if (tag === ");
                    s.push_str(&options.types_namespace);
                    s.push('.');
                    s.push_str(name);
                    s.push('.');
                    s.push_str(variant.name);
                    s.push_str(") {\n            return 2 + TypedpackMaxLength.");
                    s.push_str(variant.r#type);
                    s.push_str("(value);\n        }\n");
                }
                s.push_str("        throw new Error(\"invalid enum tag\");\n    }\n}\n\nnamespace TypedpackEncodeInternal {\n    export const ");
                s.push_str(name);
                s.push_str(" = (tagValue: ");
                s.push_str(&type_union);
                s.push_str(", data: DataView, offset: number): number => {\n        const [tag, value] = tagValue;\n\n");
                for variant in variants {
                    s.push_str("        if (tag === ");
                    s.push_str(&options.types_namespace);
                    s.push('.');
                    s.push_str(name);
                    s.push('.');
                    s.push_str(variant.name);
                    s.push_str(
                        ") {\n            data.setUint8(offset, 0x92);\n            data.setUint8(offset + 1, ",
                    );
                    s.push_str(&variant.id.to_string());
                    s.push_str(");\n            return 2 + TypedpackEncodeInternal.");
                    s.push_str(variant.r#type);
                    s.push_str("(value, data, offset + 2);\n        }\n");
                }
                s.push_str(
                    "        throw new Error(\"invalid enum tag\");\n    }\n}\n\nexport namespace ",
                );
                s.push_str(&options.encode_namespace);
                s.push_str(" {\n    export const ");
                s.push_str(name);
                s.push_str(" = (value: ");
                s.push_str(&type_union);
                s.push_str("): DataView<ArrayBuffer> => {\n        const maxByteLength = TypedpackMaxLength.");
                s.push_str(name);
                s.push_str("(value);\n        const data = new DataView(new ArrayBuffer(maxByteLength, { maxByteLength }));\n        const length = TypedpackEncodeInternal.");
                s.push_str(name);
                s.push_str("(value, data, 0);\n        data.buffer.resize(length);\n        return data;\n    }\n}\n\n");
                if options.export_decode_internal_namespace {
                    s.push_str("export ");
                }
                s.push_str("namespace TypedpackDecodeInternal {\n    export const ");
                s.push_str(name);
                s.push_str(" = (data: DataView, offset: number = 0): [");
                s.push_str(&type_union);
                s.push_str(", number] => {\n        if (data.getUint8(offset) != 0x92) {\n            throw new Error(\"invalid enum tag\");\n        }\n        offset += 1;\n        const tag = data.getUint8(offset);\n        offset += 1;\n        if (!");
                s.push_str(&options.types_namespace);
                s.push('.');
                s.push_str(name);
                s.push_str(
                    "[tag]) {\n            throw new Error(\"invalid enum tag\");\n        }\n",
                );

                for variant in variants {
                    s.push_str("        if (tag === ");
                    s.push_str(&options.types_namespace);
                    s.push('.');
                    s.push_str(name);
                    s.push('.');
                    s.push_str(variant.name);
                    s.push_str(
                        ") {\n            const [value, newOffset] = TypedpackDecodeInternal.",
                    );
                    s.push_str(variant.r#type);
                    s.push_str("(data, offset);\n            offset = newOffset;\n            return [[tag, value], offset];\n        }\n");
                }

                s.push_str(
                    "        throw new Error(\"invalid enum tag\");\n    }\n}\n\nexport namespace ",
                );
                s.push_str(&options.decode_namespace);
                s.push_str(" {\n    export const ");
                s.push_str(name);
                s.push_str(" = (data: ArrayBuffer, offset: number = 0): ");
                s.push_str(&type_union);
                s.push_str(" => TypedpackDecodeInternal.");
                s.push_str(name);
                s.push_str("(new DataView(data), offset)[0];\n}\n\nexport namespace ");
                s.push_str(&options.encode_array_namespace);
                s.push_str(" {\n    export const ");
                s.push_str(name);
                s.push_str(" = (value: Array<");
                s.push_str(&type_union);
                s.push_str(">): DataView<ArrayBuffer> => {\n        const maxByteLength = arrayHeaderLength(value.length) + value.reduce((sum, item) => sum + TypedpackMaxLength.");
                s.push_str(name);
                s.push_str("(item), 0);\n        const data = new DataView(new ArrayBuffer(maxByteLength, { maxByteLength }));\n        let offset = encodeArrayHeader(value.length, data, 0);\n        for (const item of value) {\n            offset += TypedpackEncodeInternal.");
                s.push_str(name);
                s.push_str("(item, data, offset);\n        }\n        data.buffer.resize(offset);\n        return data;\n    }\n}\n\nexport namespace ");
                s.push_str(&options.decode_array_namespace);
                s.push_str(" {\n    export const ");
                s.push_str(name);
                s.push_str(" = (data: DataView, offset: number = 0): Array<");
                s.push_str(&type_union);
                s.push_str("> => {\n        const [length, newOffset] = decodeArrayLength(data, offset);\n        offset = newOffset;\n        const values = [];\n        for (let i = 0; i < length; i += 1) {\n            const [value, newOffset] = TypedpackDecodeInternal.");
                s.push_str(name);
                s.push_str("(data, offset);\n            offset = newOffset;\n            values.push(value);\n        }\n        return values;\n    };\n}");
                s
            }
            Self::Untagged { name, variants } => {
                let mut s = String::from("export namespace ");
                s.push_str(&options.types_namespace);
                s.push_str(" {\n    export enum ");
                s.push_str(name);
                s.push_str(" {\n");

                for variant in variants {
                    s.push_str("        ");
                    s.push_str(variant.name);
                    s.push_str(" = ");
                    s.push_str(&variant.id.to_string());
                    s.push_str(",\n");
                }

                s.push_str("    }\n}\n\nnamespace TypedpackMaxLength {\n    export const ");
                s.push_str(name);
                s.push_str(" = (_value: ");
                s.push_str(&options.types_namespace);
                s.push('.');
                s.push_str(name);
                s.push_str(
                    "): number => 1;\n}\n\nnamespace TypedpackEncodeInternal {\n    export const ",
                );
                s.push_str(name);
                s.push_str(" = (value: ");
                s.push_str(&options.types_namespace);
                s.push('.');
                s.push_str(name);
                s.push_str(", data: DataView, offset: number): number => {\n        data.setUint8(offset, value);\n        return 1;\n    };\n}\n\nexport namespace ");
                s.push_str(&options.encode_namespace);
                s.push_str(" {\n    export const ");
                s.push_str(name);
                s.push_str(" = (value: ");
                s.push_str(&options.types_namespace);
                s.push('.');
                s.push_str(name);
                s.push_str("): DataView<ArrayBuffer> => {\n        const data = new DataView(new ArrayBuffer(1));\n        TypedpackEncodeInternal.");
                s.push_str(name);
                s.push_str("(value, data, 0);\n        return data;\n    }\n}\n\n");
                if options.export_decode_internal_namespace {
                    s.push_str("export ");
                }
                s.push_str("namespace TypedpackDecodeInternal {\n    export const ");
                s.push_str(name);
                s.push_str(" = (data: DataView, offset: number = 0): [");
                s.push_str(&options.types_namespace);
                s.push('.');
                s.push_str(name);
                s.push_str(
                    ", number] => {\n        const value = data.getUint8(offset);\n        if (!",
                );
                s.push_str(&options.types_namespace);
                s.push('.');
                s.push_str(name);
                s.push_str(
                    "[value]) {\n            throw new Error(`${value} is not a variant of ",
                );
                s.push_str(name);
                s.push_str("`);\n        }\n        return [value, offset + 1];\n    };\n}\n\nexport namespace ");
                s.push_str(&options.decode_namespace);
                s.push_str(" {\n    export const ");
                s.push_str(name);
                s.push_str(" = (data: ArrayBuffer, offset: number = 0): ");
                s.push_str(&options.types_namespace);
                s.push('.');
                s.push_str(name);
                s.push_str(" => TypedpackDecodeInternal.");
                s.push_str(name);
                s.push_str("(new DataView(data), offset)[0];\n}\n\nexport namespace ");
                s.push_str(&options.encode_array_namespace);
                s.push_str(" {\n    export const ");
                s.push_str(name);
                s.push_str(" = (value: Array<");
                s.push_str(&options.types_namespace);
                s.push('.');
                s.push_str(name);
                s.push_str(">): DataView<ArrayBuffer> => {\n    const maxByteLength = arrayHeaderLength(value.length) + value.reduce((sum, item) => sum + TypedpackMaxLength.");
                s.push_str(name);
                s.push_str("(item), 0);\n        const data = new DataView(new ArrayBuffer(maxByteLength, { maxByteLength }));\n        let offset = encodeArrayHeader(value.length, data, 0);\n        for (const item of value) {\n            offset += TypedpackEncodeInternal.");
                s.push_str(name);
                s.push_str("(item, data, offset);\n        }\n        data.buffer.resize(offset);\n        return data;\n    }\n}\n\nexport namespace ");
                s.push_str(&options.decode_array_namespace);
                s.push_str(" {\n    export const ");
                s.push_str(name);
                s.push_str(" = (data: DataView, offset: number = 0): Array<");
                s.push_str(&options.types_namespace);
                s.push('.');
                s.push_str(name);
                s.push_str("> => {\n        const [length, newOffset] = decodeArrayLength(data, offset);\n        offset = newOffset;\n        const values = [];\n        for (let i = 0; i < length; i += 1) {\n            const [value, newOffset] = TypedpackDecodeInternal.");
                s.push_str(name);
                s.push_str("(data, offset);\n            offset = newOffset;\n            values.push(value);\n        }\n        return values;\n    };\n}");
                s
            }
        }
    }
}

impl StructField<'_> {
    /// Generates a TypeScript `interface` field.
    pub fn typescript_interface_field(&self) -> String {
        let mut s = self.name.to_owned();
        if self.optional {
            s.push('?');
        }
        s.push_str(": ");
        s.push_str(&self.r#type.typescript_type());
        if self.nullable {
            s.push_str(" | null");
        }
        s.push(';');
        s
    }
}

impl StructFieldType<'_> {
    fn typescript_encoded_max_len(&self, name: &str) -> String {
        match self {
            Self::Bool => String::from("1"),
            Self::U8 | Self::I8 => String::from("2"),
            Self::U16 | Self::I16 => String::from("3"),
            Self::U32 | Self::I32 | Self::F32 => String::from("5"),
            Self::U64 | Self::I64 | Self::F64 => String::from("9"),
            Self::String => format!("stringHeaderLength(3 * {name}.length) + 3 * {name}.length"),
            Self::Bytes { .. } => {
                format!("bytesHeaderLength({name}.byteLength) + {name}.byteLength")
            }
            Self::Array { .. } => unreachable!(),
            Self::Reference { name: type_name } => {
                format!("TypedpackMaxLength.{type_name}({name})")
            }
        }
    }

    /// Returns the corresponding TypeScript type.
    pub fn typescript_type(&self) -> String {
        match self {
            Self::Bool => String::from("boolean"),
            Self::U8
            | Self::I8
            | Self::U16
            | Self::I16
            | Self::U32
            | Self::I32
            | Self::F32
            | Self::F64 => String::from("number"),
            Self::U64 | Self::I64 => String::from("bigint"),
            Self::String => String::from("string"),
            Self::Bytes { .. } => String::from("ArrayBuffer"),
            Self::Array { items } => format!("Array<{items}>", items = items.typescript_type()),
            Self::Reference { name } => (*name).to_owned(),
        }
    }
}

impl Struct<'_> {
    /// Generates a TypeScript `interface` and encode/decode functions.
    pub fn typescript_interface(&self, options: &Options) -> String {
        let mut s = String::from("export namespace ");
        s.push_str(&options.types_namespace);
        s.push_str(" {\n    export ");
        if self.fields.is_empty() {
            s.push_str("type ");
        } else {
            s.push_str("interface ");
        }
        s.push_str(self.name);
        if self.fields.is_empty() {
            s.push_str(" = object;");
        } else {
            s.push_str(" {\n");
            for field in &self.fields {
                s.push_str("        ");
                s.push_str(&field.typescript_interface_field());
                s.push('\n');
            }
            s.push_str("    }");
        }
        s.push_str("\n}\n\nnamespace TypedpackMapLength {\n    export const ");
        s.push_str(self.name);
        s.push_str(" = (");

        let field_count = self.fields.len();
        let required_field_count = self.fields.iter().filter(|field| !field.optional).count();
        let required_field_count_str = required_field_count.to_string();

        if field_count == required_field_count {
            s.push('_');
        }

        s.push_str("value: ");
        s.push_str(&options.types_namespace);
        s.push('.');
        s.push_str(self.name);
        s.push_str("): number =>");

        if required_field_count == field_count {
            s.push(' ');
            s.push_str(&required_field_count_str);
        } else {
            s.push_str("\n        ");
            s.push_str(&required_field_count_str);

            for field in &self.fields {
                if !field.optional {
                    continue;
                }
                s.push_str("\n        + (Object.hasOwn(value, \"");
                s.push_str(field.name);
                s.push_str("\") ? 1 : 0)");
            }
        }

        s.push_str(";\n}\n\nnamespace TypedpackMaxLength {\n    export const ");
        s.push_str(self.name);
        s.push_str(" = (");
        if field_count == 0 {
            s.push('_');
        }
        s.push_str("value: ");
        s.push_str(&options.types_namespace);
        s.push('.');
        s.push_str(self.name);

        if field_count == 0 {
            s.push_str("): number => 1");
        } else {
            s.push_str("): number =>\n        mapHeaderLength(TypedpackMapLength.");
            s.push_str(self.name);
            s.push_str("(value))");

            if required_field_count != 0 {
                s.push_str("\n            + ");
                s.push_str(&required_field_count_str);
            }
        }

        for field in &self.fields {
            s.push_str("\n            + ");
            if field.optional {
                s.push_str("(\n                Object.hasOwn(value, \"");
                s.push_str(field.name);
                s.push_str("\")\n                ? 1 + ");
            }
            if field.nullable {
                s.push_str("(value.");
                s.push_str(field.name);
                s.push_str(" === null ? 1 : ");
            }

            let mut field_type = &field.r#type;
            let mut array_depth: usize = 0;
            loop {
                match field_type {
                    StructFieldType::Array { items } => {
                        if array_depth == 0 {
                            s.push_str("arrayHeaderLength(");
                            s.push_str("value.");
                            s.push_str(field.name);
                            if field.optional || field.nullable {
                                s.push('!');
                            }
                            s.push_str(".length) + value.");
                            s.push_str(field.name);
                            if field.optional || field.nullable {
                                s.push('!');
                            }
                        } else {
                            s.push_str(".reduce((sum, item) => sum + arrayHeaderLength(item.length) + item");
                        }
                        field_type = items;
                        array_depth += 1;
                    }
                    StructFieldType::Bool
                    | StructFieldType::U8
                    | StructFieldType::I8
                    | StructFieldType::U16
                    | StructFieldType::I16
                    | StructFieldType::U32
                    | StructFieldType::I32
                    | StructFieldType::U64
                    | StructFieldType::I64
                    | StructFieldType::F32
                    | StructFieldType::F64 => {
                        if array_depth != 0 {
                            s.push_str(".length * ");
                        }
                        s.push_str(&field_type.typescript_encoded_max_len(""));
                        break;
                    }
                    StructFieldType::String
                    | StructFieldType::Bytes { .. }
                    | StructFieldType::Reference { .. } => {
                        if array_depth == 0 {
                            s.push_str(&field_type.typescript_encoded_max_len(&format!(
                                "value.{name}{assert_non_null}",
                                name = field.name,
                                assert_non_null = if field.optional || field.nullable {
                                    "!"
                                } else {
                                    ""
                                }
                            )));
                        } else {
                            s.push_str(".map((item) => ");
                            s.push_str(&field_type.typescript_encoded_max_len("item"));
                            s.push_str(").reduce((sum, item) => sum + item, 0)");
                        }
                        break;
                    }
                }
            }

            for _ in 1..array_depth {
                s.push_str(", 0)");
            }

            if field.nullable {
                s.push(')');
            }
            if field.optional {
                s.push_str("\n                : 0\n            )");
            }
        }

        s.push_str(";\n}\n\nnamespace TypedpackEncodeInternal {\n    export const ");
        s.push_str(self.name);
        s.push_str(" = (value: ");
        s.push_str(&options.types_namespace);
        s.push('.');
        s.push_str(self.name);
        s.push_str(", data: DataView, offset: number): number => {\n        const originalOffset = offset;\n        offset += encodeMapHeader(TypedpackMapLength.");
        s.push_str(self.name);
        s.push_str("(value), data, offset);");

        for field in &self.fields {
            s.push_str("\n\n");
            if field.optional {
                s.push_str("        if (Object.hasOwn(value, \"");
                s.push_str(field.name);
                s.push_str("\")) {\n    ");
            }

            s.push_str("        offset += encodeUint(");
            s.push_str(&field.id.to_string());
            s.push_str(", data, offset);\n");

            if field.nullable {
                if field.optional {
                    s.push_str("    ");
                }
                s.push_str("        if (value.");
                s.push_str(field.name);
                s.push_str(" === null) {\n            ");
                if field.optional {
                    s.push_str("    ");
                }
                s.push_str("offset += encodeNull(data, offset);\n        ");
                if field.optional {
                    s.push_str("    ");
                }
                s.push_str("} else {\n");
            }

            let mut field_type = &field.r#type;
            let mut array_depth = 0;
            loop {
                let get_value_name = |depth| {
                    if depth == 0 {
                        let mut value_name = String::with_capacity(field.name.len() + 7);
                        value_name.push_str("value.");
                        value_name.push_str(field.name);
                        if field.optional {
                            value_name.push('!');
                        }
                        value_name
                    } else {
                        format!("item{depth}", depth = depth - 1)
                    }
                };
                let value_name = get_value_name(array_depth);

                let indent = " ".repeat(
                    8 + 4 * array_depth
                        + if field.optional { 4 } else { 0 }
                        + if field.nullable { 4 } else { 0 },
                );
                s.push_str(&indent);

                match field_type {
                    StructFieldType::Bool => {
                        s.push_str("offset += encodeBoolean(");
                        s.push_str(&value_name);
                        s.push_str(", data, offset);");
                        break;
                    }
                    StructFieldType::U8 => {
                        s.push_str("if (!Number.isSafeInteger(");
                        s.push_str(&value_name);
                        s.push_str(") || ");
                        s.push_str(&value_name);
                        s.push_str(" < 0 || ");
                        s.push_str(&value_name);
                        s.push_str(" >= 256) {\n");
                        s.push_str(&indent);
                        s.push_str("    throw new Error(\"invalid uint8\");\n");
                        s.push_str(&indent);
                        s.push_str("}\n");
                        s.push_str(&indent);
                        s.push_str("offset += encodeUint(");
                        s.push_str(&value_name);
                        s.push_str(", data, offset);");
                        break;
                    }
                    StructFieldType::I8 => {
                        s.push_str("if (!Number.isSafeInteger(");
                        s.push_str(&value_name);
                        s.push_str(") || ");
                        s.push_str(&value_name);
                        s.push_str(" < -128 || ");
                        s.push_str(&value_name);
                        s.push_str(" >= 128) {\n");
                        s.push_str(&indent);
                        s.push_str("    throw new Error(\"invalid int8\");\n");
                        s.push_str(&indent);
                        s.push_str("}\n");
                        s.push_str(&indent);
                        s.push_str("offset += encodeInt(");
                        s.push_str(&value_name);
                        s.push_str(", data, offset);");
                        break;
                    }
                    StructFieldType::U16 => {
                        s.push_str("if (!Number.isSafeInteger(");
                        s.push_str(&value_name);
                        s.push_str(") || ");
                        s.push_str(&value_name);
                        s.push_str(" < 0 || ");
                        s.push_str(&value_name);
                        s.push_str(" >= 65_536) {\n");
                        s.push_str(&indent);
                        s.push_str("    throw new Error(\"invalid uint16\");\n");
                        s.push_str(&indent);
                        s.push_str("}\n");
                        s.push_str(&indent);
                        s.push_str("offset += encodeUint(");
                        s.push_str(&value_name);
                        s.push_str(", data, offset);");
                        break;
                    }
                    StructFieldType::I16 => {
                        s.push_str("if (!Number.isSafeInteger(");
                        s.push_str(&value_name);
                        s.push_str(") || ");
                        s.push_str(&value_name);
                        s.push_str(" < -32_768 || ");
                        s.push_str(&value_name);
                        s.push_str(" >= 32_768) {\n");
                        s.push_str(&indent);
                        s.push_str("    throw new Error(\"invalid int16\");\n");
                        s.push_str(&indent);
                        s.push_str("}\n");
                        s.push_str(&indent);
                        s.push_str("offset += encodeInt(");
                        s.push_str(&value_name);
                        s.push_str(", data, offset);");
                        break;
                    }
                    StructFieldType::U32 => {
                        s.push_str("if (!Number.isSafeInteger(");
                        s.push_str(&value_name);
                        s.push_str(") || ");
                        s.push_str(&value_name);
                        s.push_str(" < 0 || ");
                        s.push_str(&value_name);
                        s.push_str(" >= 4_294_967_296) {\n");
                        s.push_str(&indent);
                        s.push_str("    throw new Error(\"invalid uint32\");\n");
                        s.push_str(&indent);
                        s.push_str("}\n");
                        s.push_str(&indent);
                        s.push_str("offset += encodeUint(");
                        s.push_str(&value_name);
                        s.push_str(", data, offset);");
                        break;
                    }
                    StructFieldType::I32 => {
                        s.push_str("if (!Number.isSafeInteger(");
                        s.push_str(&value_name);
                        s.push_str(") || ");
                        s.push_str(&value_name);
                        s.push_str(" < -2_147_483_648 || ");
                        s.push_str(&value_name);
                        s.push_str(" >= 2_147_483_648) {\n");
                        s.push_str(&indent);
                        s.push_str("    throw new Error(\"invalid int32\");\n");
                        s.push_str(&indent);
                        s.push_str("}\n");
                        s.push_str(&indent);
                        s.push_str("offset += encodeInt(");
                        s.push_str(&value_name);
                        s.push_str(", data, offset);");
                        break;
                    }
                    StructFieldType::U64 => {
                        s.push_str("if (");
                        s.push_str(&value_name);
                        s.push_str(" < 0n || ");
                        s.push_str(&value_name);
                        s.push_str(" >= 18_446_744_073_709_551_616n) {\n");
                        s.push_str(&indent);
                        s.push_str("    throw new Error(\"invalid uint64\");\n");
                        s.push_str(&indent);
                        s.push_str("}\n");
                        s.push_str(&indent);
                        s.push_str("offset += encodeUint64(");
                        s.push_str(&value_name);
                        s.push_str(", data, offset);");
                        break;
                    }
                    StructFieldType::I64 => {
                        s.push_str("if (");
                        s.push_str(&value_name);
                        s.push_str(" < -9_223_372_036_854_775_808n || ");
                        s.push_str(&value_name);
                        s.push_str(" >= 9_223_372_036_854_775_808n) {\n");
                        s.push_str(&indent);
                        s.push_str("    throw new Error(\"invalid int64\");\n");
                        s.push_str(&indent);
                        s.push_str("}\n");
                        s.push_str(&indent);
                        s.push_str("offset += encodeInt64(");
                        s.push_str(&value_name);
                        s.push_str(", data, offset);");
                        break;
                    }
                    StructFieldType::F32 => {
                        s.push_str("offset += encodeFloat32(");
                        s.push_str(&value_name);
                        s.push_str(", data, offset);");
                        break;
                    }
                    StructFieldType::F64 => {
                        s.push_str("offset += encodeFloat64(");
                        s.push_str(&value_name);
                        s.push_str(", data, offset);");
                        break;
                    }
                    StructFieldType::String => {
                        s.push_str("offset += encodeString(");
                        s.push_str(&value_name);
                        s.push_str(", data, offset);");
                        break;
                    }
                    StructFieldType::Bytes { len } => {
                        s.push_str("offset += encodeBytes(");
                        s.push_str(&value_name);
                        s.push_str(", data, offset");
                        if let Some(len) = len {
                            s.push_str(", ");
                            s.push_str(&len.to_string());
                        }
                        s.push_str(");");
                        break;
                    }
                    StructFieldType::Array { items } => {
                        s.push_str("offset += encodeArrayHeader(");
                        s.push_str(&value_name);
                        s.push_str(".length, data, offset);\n");
                        s.push_str(&indent);
                        s.push_str("for (const ");
                        s.push_str(&get_value_name(array_depth + 1));
                        s.push_str(" of ");
                        s.push_str(&value_name);
                        s.push_str(") {\n");
                        field_type = items;
                        array_depth += 1;
                    }
                    StructFieldType::Reference { name } => {
                        s.push_str("{\n");
                        s.push_str(&indent);
                        s.push_str("    offset += TypedpackEncodeInternal.");
                        s.push_str(name);
                        s.push('(');
                        s.push_str(&value_name);
                        s.push_str(", data, offset);\n");
                        s.push_str(&indent);
                        s.push('}');
                        break;
                    }
                }
            }

            for depth in (0..array_depth).rev() {
                s.push('\n');
                for _ in 0..4 * depth
                    + if field.optional { 4 } else { 0 }
                    + if field.nullable { 4 } else { 0 }
                    + 8
                {
                    s.push(' ');
                }
                s.push('}');
            }

            if field.nullable {
                s.push_str("\n        ");
                if field.optional {
                    s.push_str("    ");
                }
                s.push('}');
            }

            if field.optional {
                s.push_str("\n        }");
            }
        }

        s.push_str("\n\n        return offset - originalOffset;\n    };\n}\n\nexport namespace ");
        s.push_str(&options.encode_namespace);
        s.push_str(" {\n    export const ");
        s.push_str(self.name);
        s.push_str(" = (value: ");
        s.push_str(&options.types_namespace);
        s.push('.');
        s.push_str(self.name);
        s.push_str("): DataView<ArrayBuffer> => {\n        const maxByteLength = TypedpackMaxLength.");
        s.push_str(self.name);
        s.push_str("(value);\n        const data = new DataView(new ArrayBuffer(maxByteLength, { maxByteLength }));\n        const length = TypedpackEncodeInternal.");
        s.push_str(self.name);
        s.push_str("(value, data, 0);\n        data.buffer.resize(length);\n        return data;\n    }\n}\n\n");

        if options.export_decode_internal_namespace {
            s.push_str("export ");
        }
        s.push_str("namespace TypedpackDecodeInternal {\n    export const ");
        s.push_str(self.name);
        s.push_str(" = (data: DataView, offset: number = 0): [");
        s.push_str(&options.types_namespace);
        s.push('.');
        s.push_str(self.name);
        s.push_str(", number] => {\n        const obj: Partial<");
        s.push_str(&options.types_namespace);
        s.push('.');
        s.push_str(self.name);
        s.push_str("> = Object.create(null);\n        const seenKeys = new Set();\n        const [mapLength, newOffset] = decodeMapLength(data, offset);\n        offset = newOffset;\n\n        for (let i = 0; i < mapLength; i += 1) {\n            const key = decodeMapKey(data, offset);\n            offset += 1;\n            if (seenKeys.has(key)) {\n                throw new Error(`duplicate map key '${key}'`);\n            }\n            seenKeys.add(key);\n\n            ");

        for (i, field) in self.fields.iter().enumerate() {
            if i != 0 {
                s.push_str(" else ");
            }
            s.push_str("if (key === ");
            s.push_str(&field.id.to_string());
            s.push_str(") {\n");

            let mut array_depth = 0;
            let mut field_type = &field.r#type;

            if field.nullable {
                s.push_str("                if (data.getUint8(offset) === 0xc0) {\n                    obj.");
                s.push_str(field.name);
                s.push_str(
                    " = null;\n                    offset += 1;\n                } else {\n",
                );
            }

            loop {
                let indent = " ".repeat(4 * array_depth + if field.nullable { 4 } else { 0 } + 16);
                s.push_str(&indent);

                match field_type {
                    StructFieldType::Bool => {
                        if array_depth == 0 {
                            s.push_str("[obj.");
                            s.push_str(field.name);
                            s.push_str(", offset] = decodeBoolean(data, offset);");
                        } else {
                            s.push_str("const [value, newOffset] = decodeBoolean(data, offset);\n");
                            s.push_str(&indent);
                            s.push_str("offset = newOffset;\n");
                            s.push_str(&indent);
                            s.push_str("array");
                            s.push_str(&(array_depth - 1).to_string());
                            s.push_str(".push(value);");
                        }
                        break;
                    }
                    StructFieldType::U8 => {
                        s.push_str("const [value, newOffset] = decodeInt(data, offset);\n");
                        s.push_str(&indent);
                        s.push_str("offset = newOffset;\n");
                        s.push_str(&indent);
                        s.push_str("if (value < 0 || value >= 256) {\n");
                        s.push_str(&indent);
                        s.push_str("    throw new Error(\"invalid uint8\");\n");
                        s.push_str(&indent);
                        s.push_str("}\n");
                        s.push_str(&indent);
                        if array_depth == 0 {
                            s.push_str("obj.");
                            s.push_str(field.name);
                            s.push_str(" = value;");
                        } else {
                            s.push_str("array");
                            s.push_str(&(array_depth - 1).to_string());
                            s.push_str(".push(value);");
                        }
                        break;
                    }
                    StructFieldType::I8 => {
                        s.push_str("const [value, newOffset] = decodeInt(data, offset);\n");
                        s.push_str(&indent);
                        s.push_str("offset = newOffset;\n");
                        s.push_str(&indent);
                        s.push_str("if (value < -128 || value >= 128) {\n");
                        s.push_str(&indent);
                        s.push_str("    throw new Error(\"invalid int8\");\n");
                        s.push_str(&indent);
                        s.push_str("}\n");
                        s.push_str(&indent);
                        if array_depth == 0 {
                            s.push_str("obj.");
                            s.push_str(field.name);
                            s.push_str(" = value;");
                        } else {
                            s.push_str("array");
                            s.push_str(&(array_depth - 1).to_string());
                            s.push_str(".push(value);");
                        }
                        break;
                    }
                    StructFieldType::U16 => {
                        s.push_str("const [value, newOffset] = decodeInt(data, offset);\n");
                        s.push_str(&indent);
                        s.push_str("offset = newOffset;\n");
                        s.push_str(&indent);
                        s.push_str("if (value < 0 || value >= 65_536) {\n");
                        s.push_str(&indent);
                        s.push_str("    throw new Error(\"invalid uint16\");\n");
                        s.push_str(&indent);
                        s.push_str("}\n");
                        s.push_str(&indent);
                        if array_depth == 0 {
                            s.push_str("obj.");
                            s.push_str(field.name);
                            s.push_str(" = value;");
                        } else {
                            s.push_str("array");
                            s.push_str(&(array_depth - 1).to_string());
                            s.push_str(".push(value);");
                        }
                        break;
                    }
                    StructFieldType::I16 => {
                        s.push_str("const [value, newOffset] = decodeInt(data, offset);\n");
                        s.push_str(&indent);
                        s.push_str("offset = newOffset;\n");
                        s.push_str(&indent);
                        s.push_str("if (value < -32_768 || value >= 32_768) {\n");
                        s.push_str(&indent);
                        s.push_str("    throw new Error(\"invalid int16\");\n");
                        s.push_str(&indent);
                        s.push_str("}\n");
                        s.push_str(&indent);
                        if array_depth == 0 {
                            s.push_str("obj.");
                            s.push_str(field.name);
                            s.push_str(" = value;");
                        } else {
                            s.push_str("array");
                            s.push_str(&(array_depth - 1).to_string());
                            s.push_str(".push(value);");
                        }
                        break;
                    }
                    StructFieldType::U32 => {
                        s.push_str("const [value, newOffset] = decodeInt(data, offset);\n");
                        s.push_str(&indent);
                        s.push_str("offset = newOffset;\n");
                        s.push_str(&indent);
                        s.push_str("if (value < 0) {\n");
                        s.push_str(&indent);
                        s.push_str("    throw new Error(\"invalid uint32\");\n");
                        s.push_str(&indent);
                        s.push_str("}\n");
                        s.push_str(&indent);
                        if array_depth == 0 {
                            s.push_str("obj.");
                            s.push_str(field.name);
                            s.push_str(" = value;");
                        } else {
                            s.push_str("array");
                            s.push_str(&(array_depth - 1).to_string());
                            s.push_str(".push(value);");
                        }
                        break;
                    }
                    StructFieldType::I32 => {
                        s.push_str("const [value, newOffset] = decodeInt(data, offset);\n");
                        s.push_str(&indent);
                        s.push_str("offset = newOffset;\n");
                        s.push_str(&indent);
                        s.push_str("if (value >= 2_147_483_648) {\n");
                        s.push_str(&indent);
                        s.push_str("    throw new Error(\"invalid int32\");\n");
                        s.push_str(&indent);
                        s.push_str("}\n");
                        s.push_str(&indent);
                        if array_depth == 0 {
                            s.push_str("obj.");
                            s.push_str(field.name);
                            s.push_str(" = value;");
                        } else {
                            s.push_str("array");
                            s.push_str(&(array_depth - 1).to_string());
                            s.push_str(".push(value);");
                        }
                        break;
                    }
                    StructFieldType::U64 => {
                        s.push_str("const [value, newOffset] = decodeInt64(data, offset);\n");
                        s.push_str(&indent);
                        s.push_str("offset = newOffset;\n");
                        s.push_str(&indent);
                        s.push_str("if (value < 0n) {\n");
                        s.push_str(&indent);
                        s.push_str("    throw new Error(\"invalid uint64\");\n");
                        s.push_str(&indent);
                        s.push_str("}\n");
                        s.push_str(&indent);
                        if array_depth == 0 {
                            s.push_str("obj.");
                            s.push_str(field.name);
                            s.push_str(" = value;");
                        } else {
                            s.push_str("array");
                            s.push_str(&(array_depth - 1).to_string());
                            s.push_str(".push(value);");
                        }
                        break;
                    }
                    StructFieldType::I64 => {
                        s.push_str("const [value, newOffset] = decodeInt64(data, offset);\n");
                        s.push_str(&indent);
                        s.push_str("offset = newOffset;\n");
                        s.push_str(&indent);
                        s.push_str("if (value >= 9_223_372_036_854_775_808n) {\n");
                        s.push_str(&indent);
                        s.push_str("    throw new Error(\"invalid int64\");\n");
                        s.push_str(&indent);
                        s.push_str("}\n");
                        s.push_str(&indent);
                        if array_depth == 0 {
                            s.push_str("obj.");
                            s.push_str(field.name);
                            s.push_str(" = value;");
                        } else {
                            s.push_str("array");
                            s.push_str(&(array_depth - 1).to_string());
                            s.push_str(".push(value);");
                        }
                        break;
                    }
                    StructFieldType::F32 => {
                        if array_depth == 0 {
                            s.push_str("[obj.");
                            s.push_str(field.name);
                            s.push_str(", offset] = decodeFloat32(data, offset);");
                        } else {
                            s.push_str("const [value, newOffset] = decodeFloat32(data, offset);\n");
                            s.push_str(&indent);
                            s.push_str("offset = newOffset;\n");
                            s.push_str(&indent);
                            s.push_str("array");
                            s.push_str(&(array_depth - 1).to_string());
                            s.push_str(".push(value);");
                        }
                        break;
                    }
                    StructFieldType::F64 => {
                        if array_depth == 0 {
                            s.push_str("[obj.");
                            s.push_str(field.name);
                            s.push_str(", offset] = decodeFloat64(data, offset);");
                        } else {
                            s.push_str("const [value, newOffset] = decodeFloat64(data, offset);\n");
                            s.push_str(&indent);
                            s.push_str("offset = newOffset;\n");
                            s.push_str(&indent);
                            s.push_str("array");
                            s.push_str(&(array_depth - 1).to_string());
                            s.push_str(".push(value);");
                        }
                        break;
                    }
                    StructFieldType::String => {
                        if array_depth == 0 {
                            s.push_str("[obj.");
                            s.push_str(field.name);
                            s.push_str(", offset] = decodeString(data, offset);");
                        } else {
                            s.push_str("const [value, newOffset] = decodeString(data, offset);\n");
                            s.push_str(&indent);
                            s.push_str("offset = newOffset;\n");
                            s.push_str(&indent);
                            s.push_str("array");
                            s.push_str(&(array_depth - 1).to_string());
                            s.push_str(".push(value);");
                        }
                        break;
                    }
                    StructFieldType::Bytes { len } => {
                        if array_depth == 0 {
                            s.push_str("[obj.");
                            s.push_str(field.name);
                            s.push_str(", offset] = decodeBytes(data, offset");
                            if let Some(len) = len {
                                s.push_str(", ");
                                s.push_str(&len.to_string());
                            }
                            s.push_str(");");
                        } else {
                            s.push_str("const [value, newOffset] = decodeBytes(data, offset");
                            if let Some(len) = len {
                                s.push_str(", ");
                                s.push_str(&len.to_string());
                            }
                            s.push_str(");\n");
                            s.push_str(&indent);
                            s.push_str("offset = newOffset;\n");
                            s.push_str(&indent);
                            s.push_str("array");
                            s.push_str(&(array_depth - 1).to_string());
                            s.push_str(".push(value);");
                        }
                        break;
                    }
                    StructFieldType::Array { items } => {
                        let depth_str = array_depth.to_string();
                        s.push_str("const array");
                        s.push_str(&depth_str);
                        s.push_str(" = [];\n");
                        s.push_str(&indent);
                        s.push_str(
                            "const [length, newOffset] = decodeArrayLength(data, offset);\n",
                        );
                        s.push_str(&indent);
                        s.push_str("offset = newOffset;\n");
                        s.push_str(&indent);
                        s.push_str("for (let i");
                        s.push_str(&depth_str);
                        s.push_str(" = 0; i");
                        s.push_str(&depth_str);
                        s.push_str(" < length; i");
                        s.push_str(&depth_str);
                        s.push_str(" += 1) {\n");
                        field_type = items;
                        array_depth += 1;
                    }
                    StructFieldType::Reference { name } => {
                        if array_depth == 0 {
                            s.push_str("[obj.");
                            s.push_str(field.name);
                            s.push_str(", offset] = TypedpackDecodeInternal.");
                            s.push_str(name);
                            s.push_str("(data, offset);");
                        } else {
                            s.push_str("const [value, newOffset] = TypedpackDecodeInternal.");
                            s.push_str(name);
                            s.push_str("(data, offset);\n");
                            s.push_str(&indent);
                            s.push_str("offset = newOffset;\n");
                            s.push_str(&indent);
                            s.push_str("array");
                            s.push_str(&(array_depth - 1).to_string());
                            s.push_str(".push(value);");
                        }
                        break;
                    }
                }
            }

            for depth in (0..array_depth).rev() {
                s.push('\n');
                for _ in 0..16 + 4 * depth {
                    s.push(' ');
                }
                if field.nullable {
                    s.push_str("    ");
                }
                s.push_str("}\n");

                if depth == 0 {
                    if field.nullable {
                        s.push_str("    ");
                    }
                    s.push_str("                obj.");
                    s.push_str(field.name);
                    s.push_str(" = array0;");
                } else {
                    for _ in 0..16 + 4 * depth {
                        s.push(' ');
                    }
                    s.push_str("array");
                    s.push_str(&(depth - 1).to_string());
                    s.push_str(".push(array");
                    s.push_str(&depth.to_string());
                    s.push_str(");");
                }
            }

            if field.nullable {
                s.push_str("\n                }");
            }
            s.push_str("\n            }");
        }
        s.push_str("\n        }\n\n");

        if required_field_count != 0 {
            s.push_str("        for (const key of [");
            for (i, field) in self
                .fields
                .iter()
                .filter(|field| !field.optional)
                .enumerate()
            {
                if i != 0 {
                    s.push_str(", ");
                }
                s.push_str(&field.id.to_string());
            }
            s.push_str("]) {\n            if (!seenKeys.has(key)) {\n                throw new Error(`missing map key '${key}'`);\n            }\n        }\n\n");
        }
        s.push_str("        return [obj as ");
        s.push_str(&options.types_namespace);
        s.push('.');
        s.push_str(self.name);
        s.push_str(", offset];\n    };\n}\n\nexport namespace ");
        s.push_str(&options.decode_namespace);
        s.push_str(" {\n    export const ");
        s.push_str(self.name);
        s.push_str(" = (data: ArrayBuffer, offset: number = 0): ");
        s.push_str(&options.types_namespace);
        s.push('.');
        s.push_str(self.name);
        s.push_str(" => TypedpackDecodeInternal.");
        s.push_str(self.name);
        s.push_str("(new DataView(data), offset)[0];\n}\n\nexport namespace ");
        s.push_str(&options.encode_array_namespace);
        s.push_str(" {\n    export const ");
        s.push_str(self.name);
        s.push_str(" = (value: Array<");
        s.push_str(&options.types_namespace);
        s.push('.');
        s.push_str(self.name);
        s.push_str(">): DataView<ArrayBuffer> => {\n    const maxByteLength = arrayHeaderLength(value.length) + value.reduce((sum, item) => sum + TypedpackMaxLength.");
        s.push_str(self.name);
        s.push_str("(item), 0);\n        const data = new DataView(new ArrayBuffer(maxByteLength, { maxByteLength }));\n        let offset = encodeArrayHeader(value.length, data, 0);\n        for (const item of value) {\n            offset += TypedpackEncodeInternal.");
        s.push_str(self.name);
        s.push_str("(item, data, offset);\n        }\n        data.buffer.resize(offset);\n        return data;\n    }\n}\n\nexport namespace ");
        s.push_str(&options.decode_array_namespace);
        s.push_str(" {\n    export const ");
        s.push_str(self.name);
        s.push_str(" = (data: DataView, offset: number = 0): Array<");
        s.push_str(&options.types_namespace);
        s.push('.');
        s.push_str(self.name);
        s.push_str("> => {\n        const [length, newOffset] = decodeArrayLength(data, offset);\n        offset = newOffset;\n        const values = [];\n        for (let i = 0; i < length; i += 1) {\n            const [value, newOffset] = TypedpackDecodeInternal.");
        s.push_str(self.name);
        s.push_str("(data, offset);\n            offset = newOffset;\n            values.push(value);\n        }\n        return values;\n    };\n}");
        s
    }
}
