//! Helpers for code generated by [`typedpack-codegen`].

use std::fmt::Formatter;

use rmpv::Value;
use serde::de::{MapAccess, Visitor};
use serde_bytes::{ByteArray, ByteBuf};

pub use rmpv;
pub use serde;
pub use serde_bytes;
pub use serde_repr;

/// A type that a suitable variant of [`Value`] can be converted into.
pub trait FromRmpValue {
    /// Converts from [`Value`] to this type.
    fn from(value: Value) -> Result<Self, &'static str>
    where
        Self: Sized;
}

impl FromRmpValue for bool {
    fn from(value: Value) -> Result<Self, &'static str> {
        match value {
            Value::Boolean(value) => Ok(value),
            _ => Err("invalid type; expected bool"),
        }
    }
}

impl FromRmpValue for u8 {
    fn from(value: Value) -> Result<Self, &'static str> {
        match value {
            Value::Integer(value) => u8::try_from(
                value
                    .as_u64()
                    .ok_or("invalid type; expected an unsigned integer")?,
            )
            .map_err(|_| "invalid value; does not fit in u8"),
            _ => Err("invalid type; expected u8"),
        }
    }
}

impl FromRmpValue for i8 {
    fn from(value: Value) -> Result<Self, &'static str> {
        match value {
            Value::Integer(value) => i8::try_from(
                value
                    .as_i64()
                    .ok_or("invalid type; expected a signed integer")?,
            )
            .map_err(|_| "invalid value; does not fit in i8"),
            _ => Err("invalid type; expected i8"),
        }
    }
}

impl FromRmpValue for u16 {
    fn from(value: Value) -> Result<Self, &'static str> {
        match value {
            Value::Integer(value) => u16::try_from(
                value
                    .as_u64()
                    .ok_or("invalid type; expected an unsigned integer")?,
            )
            .map_err(|_| "invalid value; does not fit in u16"),
            _ => Err("invalid type; expected u16"),
        }
    }
}

impl FromRmpValue for i16 {
    fn from(value: Value) -> Result<Self, &'static str> {
        match value {
            Value::Integer(value) => i16::try_from(
                value
                    .as_i64()
                    .ok_or("invalid type; expected a signed integer")?,
            )
            .map_err(|_| "invalid value; does not fit in i16"),
            _ => Err("invalid type; expected ui16"),
        }
    }
}

impl FromRmpValue for u32 {
    fn from(value: Value) -> Result<Self, &'static str> {
        match value {
            Value::Integer(value) => u32::try_from(
                value
                    .as_u64()
                    .ok_or("invalid type; expected an unsigned integer")?,
            )
            .map_err(|_| "invalid value; does not fit in u32"),
            _ => Err("invalid type; expected u32"),
        }
    }
}

impl FromRmpValue for i32 {
    fn from(value: Value) -> Result<Self, &'static str> {
        match value {
            Value::Integer(value) => i32::try_from(
                value
                    .as_i64()
                    .ok_or("invalid type; expected a signed integer")?,
            )
            .map_err(|_| "invalid value; does not fit in i32"),
            _ => Err("invalid type; expected i32"),
        }
    }
}

impl FromRmpValue for u64 {
    fn from(value: Value) -> Result<Self, &'static str> {
        match value {
            Value::Integer(value) => value
                .as_u64()
                .ok_or("invalid type; expected an unsigned integer"),
            _ => Err("invalid type; expected u64"),
        }
    }
}

impl FromRmpValue for i64 {
    fn from(value: Value) -> Result<Self, &'static str> {
        match value {
            Value::Integer(value) => value
                .as_i64()
                .ok_or("invalid type; expected a signed integer"),
            _ => Err("invalid type; expected i64"),
        }
    }
}

impl FromRmpValue for f32 {
    fn from(value: Value) -> Result<Self, &'static str> {
        match value {
            Value::F32(value) => Ok(value),
            _ => Err("invalid type; expected f32"),
        }
    }
}

impl FromRmpValue for f64 {
    fn from(value: Value) -> Result<Self, &'static str> {
        match value {
            Value::F64(value) => Ok(value),
            _ => Err("invalid type; expected f64"),
        }
    }
}

impl FromRmpValue for String {
    fn from(value: Value) -> Result<Self, &'static str> {
        match value {
            Value::String(value) => value.into_str().ok_or("string is not UTF-8"),
            _ => Err("invalid type; expected a string"),
        }
    }
}

impl<const N: usize> FromRmpValue for ByteArray<N> {
    fn from(value: Value) -> Result<Self, &'static str> {
        match value {
            Value::Binary(value) => Ok(ByteArray::new(
                value.try_into().map_err(|_| "invalid byte array length")?,
            )),
            _ => Err("invalid type; expected a byte array"),
        }
    }
}

impl FromRmpValue for ByteBuf {
    fn from(value: Value) -> Result<Self, &'static str> {
        match value {
            Value::Binary(value) => Ok(value.into()),
            _ => Err("invalid type; expected a byte array"),
        }
    }
}

impl<T> FromRmpValue for Box<[T]>
where
    T: FromRmpValue,
{
    fn from(value: Value) -> Result<Self, &'static str> {
        match value {
            Value::Array(value) => {
                let mut mapped = Vec::with_capacity(value.len());
                for item in value {
                    mapped.push(FromRmpValue::from(item)?);
                }
                Ok(mapped.into())
            }
            _ => Err("invalid type; expected an array"),
        }
    }
}

impl<T> FromRmpValue for Option<T>
where
    T: FromRmpValue,
{
    fn from(value: Value) -> Result<Self, &'static str> {
        if matches!(value, Value::Nil) {
            Ok(None)
        } else {
            Ok(Some(FromRmpValue::from(value)?))
        }
    }
}

/// A [`Visitor`] for a map with [`u8`] keys.
pub struct MapVisitor;

impl<'de> Visitor<'de> for MapVisitor {
    type Value = Vec<(u8, Value)>;

    fn expecting(&self, formatter: &mut Formatter<'_>) -> std::fmt::Result {
        formatter.write_str("a map")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: MapAccess<'de>,
    {
        let mut entries = if let Some(size_hint) = map.size_hint() {
            Vec::with_capacity(size_hint)
        } else {
            Vec::new()
        };
        while let Some(entry) = map.next_entry()? {
            entries.push(entry);
        }
        Ok(entries)
    }
}
